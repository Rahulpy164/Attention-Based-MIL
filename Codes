import sys
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from torchvision import datasets, transforms
from torch.utils.data import Dataset, DataLoader
import argparse
from sklearn.metrics import accuracy_score, roc_auc_score
import torch.optim as optim
import matplotlib.pyplot as plt

# Set random seeds for reproducibility
def set_seed(seed=42):
    np.random.seed(seed)
    torch.manual_seed(seed)
    if torch.cuda.is_available():
        torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False

# [Keep all your existing class definitions: MnistBags, Attention, GatedAttention]
# [Keep train() and test() functions]

def plot_auc_vs_bags(args, device):
    """Generate AUC vs number of bags plots"""
    mean_bag_sizes = [10, 50, 100]
    var_bag_sizes = [2, 10, 20]
    num_train_bags_list = [50, 100, 150, 200, 300, 400, 500]

    plt.figure(figsize=(15, 5))

    for i, (mean_size, var_size) in enumerate(zip(mean_bag_sizes, var_bag_sizes)):
        results = {'attention': [], 'gated': []}

        for num_train_bags in num_train_bags_list:
            train_dataset = MnistBags(
                target_number=args.target,
                mean_bag_length=mean_size,
                var_bag_length=var_size,
                num_bag=num_train_bags,
                seed=args.seed,
                train=True
            )

            test_dataset = MnistBags(
                target_number=args.target,
                mean_bag_length=mean_size,
                var_bag_length=var_size,
                num_bag=args.num_bags_test,
                seed=args.seed+1,
                train=False
            )

            train_loader = DataLoader(train_dataset, batch_size=1, shuffle=True)
            test_loader = DataLoader(test_dataset, batch_size=1, shuffle=False)

            for model_type in ['attention', 'gated']:
                model = Attention().to(device) if model_type == 'attention' else GatedAttention().to(device)
                optimizer = optim.Adam(model.parameters(), lr=args.lr, weight_decay=args.reg)

                for epoch in range(1, args.epochs + 1):
                    train(model, train_loader, optimizer, epoch, device)

                auc_scores = []
                with torch.no_grad():
                    for data, target in test_loader:
                        data, target = data.to(device), target.float().to(device)
                        y_prob, _, _ = model(data)
                        auc_scores.append(roc_auc_score(target.cpu().numpy(), y_prob.cpu().numpy()))

                results[model_type].append(np.mean(auc_scores))

        plt.subplot(1, 3, i+1)
        for model_type, values in results.items():
            plt.plot(num_train_bags_list, values, label=model_type)
        plt.title(f'Mean: {mean_size}, Var: {var_size}')
        plt.xlabel('Training Bags')
        plt.ylabel('Test AUC')
        plt.grid()
        plt.legend()

    plt.tight_layout()
    plt.savefig('auc_vs_bags.png')
    plt.show()

def main():
    parser = argparse.ArgumentParser(description='PyTorch MNIST MIL Example')
    parser.add_argument('--epochs', type=int, default=20)
    parser.add_argument('--lr', type=float, default=0.0005)
    parser.add_argument('--reg', type=float, default=10e-5)
    parser.add_argument('--target', type=int, default=9)
    parser.add_argument('--mean-bag', type=int, default=10)
    parser.add_argument('--var-bag', type=int, default=2)
    parser.add_argument('--num-bags-train', type=int, default=200)
    parser.add_argument('--num-bags-test', type=int, default=50)
    parser.add_argument('--seed', type=int, default=42)
    parser.add_argument('--model', choices=['attention', 'gated'], default='attention')
    parser.add_argument('--no-cuda', action='store_true', default=False)
    parser.add_argument('--plot', action='store_true')

    if 'ipykernel' in sys.modules:
        args = parser.parse_args([])
    else:
        args = parser.parse_args()

    use_cuda = not args.no_cuda and torch.cuda.is_available()
    device = torch.device("cuda" if use_cuda else "cpu")
    set_seed(args.seed)

    if args.plot:
        plot_auc_vs_bags(args, device)
    else:
        train_dataset = MnistBags(
            target_number=args.target,
            mean_bag_length=args.mean_bag,
            var_bag_length=args.var_bag,
            num_bag=args.num_bags_train,
            seed=args.seed,
            train=True
        )
        test_dataset = MnistBags(
            target_number=args.target,
            mean_bag_length=args.mean_bag,
            var_bag_length=args.var_bag,
            num_bag=args.num_bags_test,
            seed=args.seed,
            train=False
        )

        train_loader = DataLoader(train_dataset, batch_size=1, shuffle=True)
        test_loader = DataLoader(test_dataset, batch_size=1, shuffle=False)

        model = Attention().to(device) if args.model == 'attention' else GatedAttention().to(device)
        optimizer = optim.Adam(model.parameters(), lr=args.lr, weight_decay=args.reg)

        for epoch in range(1, args.epochs + 1):
            train(model, train_loader, optimizer, epoch, device)
            test(model, test_loader, device)

        model.eval()
        with torch.no_grad():
            for i, (data, target) in enumerate(test_loader):
                if i >= 5:
                    break
                data, target = data.to(device), target.to(device)
                _, _, A = model(data)
                print(f"\nBag {i+1}: Target = {target.item()}")
                print("Attention weights:", A.cpu().numpy())

if __name__ == '__main__':
    main()
